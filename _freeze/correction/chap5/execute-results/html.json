{
  "hash": "d16f3806270072a5c8885d6621a0397e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"5 Régression polynomiale et régression spline\"\ntoc: true\n---\n\n\n\n\n::: {.content-hidden}\n\n\\DeclareMathOperator{\\C}{Cov}\n\\DeclareMathOperator{\\V}{V}\n\\DeclareMathOperator{\\leR}{R^2}\n\\newcommand{\\M}{\\mathcal M}\n\\DeclareMathOperator{\\MCO}{MCO}\n\\DeclareMathOperator{\\SCR}{SCR}\n\\DeclareMathOperator{\\SCT}{SCT}\n\\DeclareMathOperator{\\SCE}{SCE}\n\\DeclareMathOperator{\\EQM}{EQM}\n\\DeclareMathOperator{\\ro}{R^2_0}\n\n\\newcommand{\\1}{\\mathbf{1}}\n\\newcommand{\\un}{\\mathbf{1}}\n\\newcommand{\\D}{\\displaystyle}\n\n\n\\newcommand{\\prob}{\\mathbf P}\n\\newcommand{\\argmin}{\\mathop{\\mathrm{argmin}}}\n\\newcommand{\\ind}{\\mathbf 1}\n\\newcommand{\\R}{\\mathbb R}\n\\newcommand{\\E}{\\mathbf E}\n\\newcommand{\\var}{\\mathbf V}\n\\newcommand{\\ps}[2]{\\langle #1,#2\\rangle}\n\\newcommand{\\card}[1]{|{#1}|}\n\\newcommand{\\cov}{\\mathbf{cov}}\n\\newcommand{\\corr}{\\text{corr}}\n\\newcommand{\\AUC}{\\text{AUC}}\n\\newcommand{\\logit}{\\text{logit}}\n\\newcommand{\\diag}{\\text{diag}}\n\\newcommand{\\tr}{\\text{tr}}\n\\newcommand{\\li}[2]{#1_{#2}}\n\\newcommand{\\ssli}[2]{#1_{(#2)}}\n\\newcommand{\\HH}{{\\mathcal{H}}}\n\\newcommand{\\Hz}{{\\mathrm{H_0}}}\n\n\n:::\n\n::: {#2a4826f8 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n::: {#exr-5-1 name=\"Questions de cours\"}\n1.  C\n2.  A\n3.  A\n4.  B\n:::\n\n::: {#exr-5-2 name=\"Fonction polyreg\"}\n\n1.  On importe les données :\n\n\n    ::: {#162c21c4 .cell execution_count=3}\n    ``` {.python .cell-code}\n    ozone = pd.read_csv(\"../donnees/ozone_simple.txt\", sep=\";\")\n    sdT12 = np.std(ozone['T12'], ddof=1)\n    print(sdT12)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    4.674638477781911\n    ```\n    :::\n    :::\n    \n    \n2.  On crée la grille\n\n\n    ::: {#692a21bf .cell execution_count=4}\n    ``` {.python .cell-code}\n    grillex = np.linspace(ozone['T12'].min() - sdT12, ozone['T12'].max() + sdT12, 100)\n    ```\n    :::\n    \n    \n3.  On transforme en data frame :\n\n\n    ::: {#7d6975f2 .cell execution_count=5}\n    ``` {.python .cell-code}\n    df = pd.DataFrame({'T12': grillex})\n    ```\n    :::\n    \n    \n4.  On effectue une regression polynomiale de degré 3 :\n\n\n    ::: {#d624890f .cell execution_count=6}\n    ``` {.python .cell-code}\n    basepoly = np.column_stack([ozone['T12']**i for i in range(1, 4)])\n    newval = np.column_stack([df['T12']**i for i in range(1, 4)])\n    dfpoly = pd.DataFrame(basepoly, columns=[f'T12^{i}' for i in range(1, 4)])\n    dfpoly['O3'] = ozone['O3']\n    X = sm.add_constant(dfpoly.drop(columns='O3'))\n    Y = dfpoly['O3']\n    regpoly = sm.OLS(Y, X).fit()\n    print(regpoly.summary())\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n                                OLS Regression Results                            \n    ==============================================================================\n    Dep. Variable:                     O3   R-squared:                       0.536\n    Model:                            OLS   Adj. R-squared:                  0.505\n    Method:                 Least Squares   F-statistic:                     17.69\n    Date:                Sat, 01 Feb 2025   Prob (F-statistic):           8.92e-08\n    Time:                        18:01:00   Log-Likelihood:                -209.96\n    No. Observations:                  50   AIC:                             427.9\n    Df Residuals:                      46   BIC:                             435.6\n    Df Model:                           3                                         \n    Covariance Type:            nonrobust                                         \n    ==============================================================================\n                     coef    std err          t      P>|t|      [0.025      0.975]\n    ------------------------------------------------------------------------------\n    const         69.2720     85.128      0.814      0.420    -102.081     240.625\n    T12^1          7.4578     14.405      0.518      0.607     -21.538      36.454\n    T12^2         -0.7730      0.784     -0.986      0.330      -2.352       0.806\n    T12^3          0.0208      0.014      1.519      0.136      -0.007       0.048\n    ==============================================================================\n    Omnibus:                        2.509   Durbin-Watson:                   1.466\n    Prob(Omnibus):                  0.285   Jarque-Bera (JB):                1.745\n    Skew:                           0.251   Prob(JB):                        0.418\n    Kurtosis:                       2.235   Cond. No.                     4.15e+05\n    ==============================================================================\n    \n    Notes:\n    [1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n    [2] The condition number is large, 4.15e+05. This might indicate that there are\n    strong multicollinearity or other numerical problems.\n    ```\n    :::\n    :::\n    \n    \n5.  On prévoit sur lagrille :\n\n\n    ::: {#b75f3c32 .cell execution_count=7}\n    ``` {.python .cell-code}\n    dfnewval = pd.DataFrame(newval, columns=[f'T12^{i}' for i in range(1, 4)])\n    dfnewval = sm.add_constant(dfnewval)\n    prev = regpoly.predict(dfnewval)\n    plt.scatter(ozone['T12'], ozone['O3'], label='Données')\n    plt.plot(grillex, prev, color='red', label='Prédictions')\n    plt.xlabel('T12')\n    plt.ylabel('O3')\n    plt.xlim(5,30)\n    plt.ylim(40,140)\n    plt.legend()\n    plt.show()\n    ```\n    \n    ::: {.cell-output .cell-output-display}\n    ![](chap5_files/figure-html/cell-7-output-1.png){width=602 height=434}\n    :::\n    :::\n    \n    \n6.  Création de la fonction :\n\n\n    ::: {#f111c390 .cell execution_count=8}\n    ``` {.python .cell-code}\n    def polyreg(ozone, degre=3):\n        # Calculer l'écart-type de la colonne T12\n        sdT12 = np.std(ozone['T12'], ddof=1)\n        \n        # Créer la grille\n        grillex = np.linspace(ozone['T12'].min() - sdT12, ozone['T12'].max() + sdT12, 100)\n        \n        # Transformer en DataFrame\n        df = pd.DataFrame({'T12': grillex})\n        \n        # Créer les termes polynomiaux de degré 3\n        basepoly = np.column_stack([ozone['T12']**i for i in range(1, degre + 1)])\n        \n        # Prédire les nouvelles valeurs polynomiales\n        newval = np.column_stack([df['T12']**i for i in range(1, degre + 1)])\n        \n        # Créer le DataFrame pour la régression\n        dfpoly = pd.DataFrame(basepoly, columns=[f'T12^{i}' for i in range(1, degre + 1)])\n        dfpoly['O3'] = ozone['O3']\n        \n        # Effectuer la régression polynomiale\n        X = sm.add_constant(dfpoly.drop(columns='O3'))\n        Y = dfpoly['O3']\n        regpoly = sm.OLS(Y, X).fit()\n        \n        # Prédire les nouvelles valeurs\n        dfnewval = pd.DataFrame(newval, columns=[f'T12^{i}' for i in range(1, degre + 1)])\n        dfnewval = sm.add_constant(dfnewval)\n        prev = regpoly.predict(dfnewval)\n        \n        return grillex, prev\n    ```\n    :::\n    \n    \n:::\n\n\n::: {#exr-5-3 name=\"Fonction polyreg (suite)\"}\nOn applique la fonction précédente :\n\n::: {#526eb693 .cell execution_count=9}\n``` {.python .cell-code}\nozone = pd.read_csv(\"../donnees/ozone_simple.txt\", sep=\";\")\n# Tracer les données originales\nplt.scatter(ozone['T12'], ozone['O3'], label='Données')\nplt.xlim(0, 35)\nplt.ylim(0, 150)\n# Effectuer les régressions polynomiales et tracer les lignes\ncolors = ['blue', 'green', 'red', 'purple']\ndegrees = [1, 2, 3, 9]\nfor i, deg in enumerate(degrees):\n    grillex, prev = polyreg(ozone, degre=deg)\n    plt.plot(grillex, prev, color=colors[i], label=f'd={deg}')\n# Ajouter la légende\nplt.legend(loc='lower right')\nplt.xlabel('T12')\nplt.ylabel('O3')\nplt.xlim(5,35)\nplt.ylim(20,150)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](chap5_files/figure-html/cell-9-output-1.png){width=602 height=429}\n:::\n:::\n\n\n:::\n\n\n::: {#exr-5-4 name=\"Matrice bande\"}\nConsidérons la matrice $X_B$ du plan d’expérience obtenue à partir d’une variable réelle $X$ transformée dans $\\mathcal{S}_{\\xi}^{d+1}$ . Cette matrice est composée \ndes $d+K+1$ fonction de base notée $b_j$ et où $K$ est le nombre de noeuds intérieurs\net $d$ le degré.\n\nDans le cours, il est indiqué que les fonctions de base $b_j$ et \n$b_{j+d+1}$ en conservant l'ordre des fonctions. Donc $b_1$ est orthogonale à\ntoutes les fonctions $b_j$ avec $j>d+1$, idem pour $b_2$ avec $j>d+2$. \n\nEn faisant donc le calcul $X_B'X_B$ on obtient une matrice bande et donc\nles termes $a_{ij}$ sont nuls quand $j>i+d+1$.\n\nOn en déduit que les paramètres estimées $\\hat \\beta_k$ ne sont pas corrélés avec\nles $\\hat \\beta_j$ dès que $j>k+d+1$.\nXB est une matrice bande. \n:::\n\n",
    "supporting": [
      "chap5_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}